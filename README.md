# Advent of Code 2015
[English](#english) below.</br>

## Repositório dedicado à resolução de problemas do [Advent of Code de 2015](https://adventofcode.com/2015).

O Advent of Code é um evento anual que ocorre durante o mês de dezembro, até o dia 25 (Fazendo uma referência a [advento](https://pt.wikipedia.org/wiki/Advento)). A cada dia são liberados desafios (quebra-cabeças) relacionados a programação, mas que não necessariamente precisam ser resolvidos com programação. Cada problema para ser respondido precisa apenas de uma resposta final, que depende de uma entrada que é específica para cada usuário. Por dia são liberados duas partes de um mesmo desafio, muitas vezes relacionadas entre si, e a segunda parte apenas é liberada após a conclusão da primeira.

Existe uma disputa e os 100 primeiros a resolverem um desafio entram em um quadro de lideranças que valem pontos, mas resolvo eles sem levar em consideração esse aspecto. Alguns problemas foram discutidos com [colegas](https://github.com/heliocm) [que](https://github.com/molimat) [com](https://github.com/MariaBiancaIrace) [certeza](https://github.com/hieifn) tornaram esta uma experiência melhor. 

Abaixo deixei uma tabela com o tempo que as minhas resoluções de cada desafio demoraram. Não é garantia da complexidade de cada algoritmo, mas serve pra dar uma ideia. Cada código resolve sempre as duas partes, e não prometo que essas soluções sejam otimizadas ou que funcionem para entradas mais genéricas. O que prometo é que para as entradas que eu recebi elas retornam a resposta correta. Todos os programas foram feitos utilizando a linguagem [Python3](https://www.python.org/) e meu input também está incluso no diretório de cada dia.


### English
--- 
## Repository dedicated to the [2015 advent of code](https://adventofcode.com/2015) problem solving.

Advent of code is a annual event that happens every december, up to the 25th, in the form of a [Advent Calendar](https://en.wikipedia.org/wiki/Advent_calendar). Every day puzzles, mostly related to programming, are released and doesn't necessarily require programming to solve it. In order to be answered, each puzzle needs only a final answer which depends on an input specific to each user. Every day the puzzle is released in the form of 2 parts related to each other. The second part may only be read and answered after correctly answering the first one.

There is a score regarding the first hundred people who correctly answer each puzzle, but I mostly solve these without considering this side of the event. Some problems have been discussed with [friends]()[which]() [made]() [this]() experience better.

Below I've left a table with the running time of each of my solutions. It's not the same as the complexity, but it may give a direction. Every script is always solving both parts, and I can't assure it's the best or optimal solution, neither that they work with a more generic input. I *can* assure that for my input they gave the correct answer. All programs have been solved using [Python3](https://www.python.org/) and my input is also within each day folder.



| Dia / Day  |  Tempo de execução / Running time  |
| ------------------- | ------------------- |
|  01 |  0m0.047s |
|  02 |  0m0.045s |
|  03 |  0m0.055s |
|  04 |  0m11.442s |
|  05 |  0m0.054s |
|  06 |  0m19.660s |
|  07 |  0m0.045s |
|  08 |  0m0.046s |
|  09 |  0m0.045s |
|  10 |  0m4.893s |
|  11 |  0m3.430s |
|  12 |  0m0.058s |
|  13 |  0m1.289s |
|  14 |  0m0.053s |
|  15 |  0m7.503s |
|  16 |  0m0.046s |
|  17 |  0m0.103s |
|  18 |  0m6.758s |
|  19 |  0m0.048s |
|  20 |  1m22.794s |
|  21 |  0m0.056s |
|  22 |  0m0.879s |
|  23 |  0m0.043s |
|  24 |  0m0.284s |
|  25 |  0m4.836s |
